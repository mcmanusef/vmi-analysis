#! /bin/env python3
import sys
import ast
import argparse

import numpy as np
import numba as nb
import h5py

parser = argparse.ArgumentParser(prog='sanity-check', description=
"""This example script is useful to check that the conversion script worked correctly.
This check is limited to files that can be loaded into memory (are not too large). 
""")
parser.add_argument('--no-sort', dest='sort', action='store_false', default=True, 
help="Use a direct sort on the raw data and compare the resulting TOA values with those in the HDF5 file. This comparison \
is only valid for measurements of less than 26 seconds in length since TOA rollover correction is ignored.")

parser.add_argument('--tdc', dest='tdc', action='store_true', default=True, 
help="Check that the TDC values in the HDF5 file are all correctly sorted")

parser.add_argument('--hdf-file', dest='hdf_file', required=True, help="HDF5 result of a previous conversion.")
parser.add_argument('raw_files', metavar='raw-file', nargs='+')
args = parser.parse_args()

# Simply script to count different types of packets.
# Useful to make sure the HDF5 converter works correctly

tpx_files = args.raw_files
hdf_file = args.hdf_file

print("Raw files to read: ", args.raw_files)
print("HDF5 file to compare with: ", args.hdf_file)

@nb.njit
def count_packets(data):
    pass

    hits_ = 0
    t1r = 0
    t1f = 0
    t2r = 0
    t2f = 0
        
    last = 0
     
    for d in data:
        
        hits_ += (d >> 60) == 0xb
              
        header = d >> 56
        t1r += header == 0x6f
        t1f += header == 0x6a
        t2r += header == 0x6e
        t2f += header == 0x6b

    return hits_, t1r, t1f, t2r, t2f

@nb.njit(inline='always')
def getBits(data, high, low) -> nb.uint64:
    num = (high - low) + 1
    mask: nb.uint64 = (1 << num) - 1 # Trick: 2**N - 1 gives N consecutive ones
    maskShifted = mask << low
     
    return (data & maskShifted) >> low

@nb.njit(inline='always')
def getTOAPico(data) -> nb.uint64:
    ftoa = getBits(data, 19, 16)
    toa = getBits(data, 43, 30)
    coarse = getBits(data, 15, 0)
     
    count = ( (((coarse << 14) + toa) << 4) - ftoa )
    return  count*1562 + count//2 # 1.5625 ns

@nb.njit
def getTOA(data):
    
    toa = np.empty_like(data)
    N = 0
    
    for d in data:
        if (d >> 60) == 0xb:
            toa[N] = getTOAPico(d)
            N += 1

    return N, toa

hits = 0

tdc1_rising = 0
tdc1_falling = 0

tdc2_rising = 0
tdc2_falling = 0

toaInFile = []

print('Counting hits and TDC in raw files...')

for t in tpx_files:
    
    data = np.fromfile(t, dtype='<u8')
        
    if args.sort:
        toaInFile.append(getTOA(data))
     
    hits_, t1r, t1f, t2r, t2f = count_packets(data)
    
    hits += hits_
    tdc1_rising += t1r
    tdc1_falling += t1f
    tdc2_rising += t2r
    tdc2_falling += t2f

print(f'Number of hits {hits}')
print(f'TDC1, rising {tdc1_rising} falling {tdc1_falling}')
print(f'TDC2, rising {tdc2_rising} falling {tdc2_falling}')

print('Checking with counts in HDF5 file..')

f = h5py.File(hdf_file, 'r')

assert f['toa'].size == hits
assert f['tot'].size == hits
assert f['x'].size == hits
assert f['y'].size == hits
assert f['frame_number'].size == hits
assert 'cluster_index' not in f or f['cluster_index'].size == hits

tdc_type = f['tdc_type'][:]

chips = len(ast.literal_eval(f.attrs['BoardLayout']))

print(f'Assuming {chips} chips according to board layout, if this is wrong the TDC comparison will fail.')

assert np.sum(tdc_type == 1) == tdc1_rising // chips
assert np.sum(tdc_type == 2) == tdc1_falling // chips
assert np.sum(tdc_type == 3) == tdc2_rising // chips
assert np.sum(tdc_type == 4) == tdc2_falling // chips

tdc_type = None # Free memory

if args.sort:
    
    toa = f['toa'][:]

    notSorted = np.sum(np.diff(toa) < 0)
     
    print('Reading TOA values into memory')
     
    assert toa[-1] < 26e12, "Cannot do sort comparison on measurements with rollover correction (longer than 26 seconds)"
     
    toaArray = np.concatenate([t[:N] for N, t in toaInFile])
    
    assert toaArray.size == hits
    
    print('Applying direct sort on RAW data...')
     
    toaArray.sort()
     
    wrong = np.sum(toa != toaArray)
     
    if wrong == 0 and notSorted == 0:
        print('Comparison succesfull, all TOA values equal')
    else:
        print(f'Oops, found {notSorted} values that were sorted incorrectly. This caused {wrong} TOA values that disagree with the sorted RAW files')
        

# Free up memory
toa, toaArray = None, None

if args.tdc:
    tdc_times = f['tdc_time'][:]

    notSorted = np.sum(np.diff(tdc_times) < 0)

    if notSorted == 0:
        print('TDC are also correctly sorted')
    else:
        print('Oops, found {notSorted} TDC that were sorted incorrectly')

    
